# medods-test-assignment

Описание задания можно увидеть в [task.md](task.md).

## Как запустить

Копируем репозиторий на машину с docker и docker-compose (простите, завернул в контейнеры - понравились они мне). 
Затем создаём в корне репозитория файл `.env` с переменной `AUTH_SECRET=<любая надёжная строка>`. 
После этого всё должно запуститься командой `docker-compose up`.

## Как пользоваться

Работу эндпоинтов API я проверял при помощи Postman. 

### GET http://localhost:8080/authorize/<user_id>

Получаем в ответ пару base64-зашифрованых (я решил шифровать оба, чего уж там) JWT, если юзер есть в базе. 
База в целях проверки предварительно населяется пользователями с такими id:

`8e190df3-599b-4f0c-9067-dbae2e6227bd`

`40fa5155-0a0a-4da8-b8d1-78b6e92d1237`

`691acc89-6e12-4217-9ac3-fbd3381794cc`
    
`e79cd612-3812-4c36-97cd-caf01c19f49d`

`8be92bf9-d76d-4f51-8bb0-6b2a572b1e48`

### POST http://localhost:8080/refresh

Отправляем `application/json` вида `{"access_token":"...", "refresh_token":"..."}`, где токены те же самые base64-зашифрованные, то мы получили в предыдущем эндпоинте. 
Взамен получаем новую пару токенов.

## Как решены проблемы

За создание и парсинг JWT отвечает модуль `github.com/dgrijalva/jwt-go`. 

Access токен в базе не хранится - да и зачем, когда мы можем его расшифровать из запроса.

Refresh токен тоже не хранится. Хранится его id, в хэшированном виде, как и требуется.

Токены защищены от изменения на стороне клиента уже тем, что это JWT - изменение нарушит подпись, что будет ясно при парсинге токена.

От попыток повторного использования токены защищены тем, что при выдаче токенов мы присваиваем им uuid, который хранится в базе в виде хэша. 
Затем, при обновлении токенов, мы проверяем наличие их id в базе: если он есть - удаляем запись и выдаём новые токены, сохраняя id новой пары; если его нет - отказываем в обновлении.

Обоюдная связь токенов обеспечена вышеупомянутым присвоением им одного общего id. 
Правда, можно было бы использовать поле iat токенов - в принципе, они создаются одновременно, и эти поля должны быть одинаковы но идея с присвоением токенам id мне показалась удобнее.

## Что осталось сделать

Покрыть код тестами. Я протестировал его вручную, но это несерьёзно.

Добавить дефолтное значение AUTH_SECRET на случай отсутствия такой переменной среды.

Настроить веб-сервер и проверить работу API через интернет. Но я и так уже опоздал.
